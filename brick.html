<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Brick Breaker Game - Levels & Themes</title>
<style>
  :root {
    --bg-dark: #222;
    --bg-light: #f2f2f2;
    --text-dark: #fff;
    --text-light: #222;
    --button-bg-dark: #09f;
    --button-bg-light: #333;
    --button-text: #fff;
  }

  body {
    background: var(--bg-dark);
    color: var(--text-dark);
    font-family: sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: background 0.3s, color 0.3s;
    min-height: 100vh;
  }

  /* Header */
  header {
    background: #2a2f38;
    color: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 2rem;
    position: sticky;
    top: 0;
    width: 100%;
    max-width: 1000px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    z-index: 10;
  }
  header h1 {
    font-family: 'Montserrat', sans-serif;
    color: #ffcc00;
    cursor: pointer;
    margin: 0;
  }
  nav ul {
    list-style: none;
    display: flex;
    gap: 1.5rem;
    margin: 0;
    padding: 0;
  }
  nav ul li {
    cursor: pointer;
    font-weight: 600;
  }
  nav ul li:hover {
    color: #ffcc00;
  }

  /* Theme Button */
  .theme-btn {
    background: #ffcc00;
    color: #222;
    border: none;
    border-radius: 6px;
    padding: 0.4rem 0.8rem;
    font-size: 1rem;
    cursor: pointer;
    font-weight: bold;
  }
  .theme-btn:hover {
    opacity: 0.9;
  }

  /* Dark theme variables */
  body.dark {
    --bg: #222;
    --text: #fff;
    --button-bg: #09f;
    --button-text: #fff;
  }
  /* Bright theme variables */
  body.bright {
    --bg: #f2f2f2;
    --text: #222;
    --button-bg: #333;
    --button-text: #fff;
  }

  /* Body and canvas */
  body {
    background: var(--bg);
    color: var(--text);
  }
  canvas {
    background: #000;
    border: 2px solid #fff;
    display: block;
    transition: background 0.3s, border 0.3s;
  }
  body.bright canvas {
    background: #fff;
    border-color: #000;
  }

  #scoreboard {
    margin-top: 10px;
    font-size: 18px;
  }
  #controls {
    margin-bottom: 8px;
  }
  button {
    padding: 5px 12px;
    font-size: 15px;
    cursor: pointer;
    border-radius: 4px;
    border: none;
    background: var(--button-bg);
    color: var(--button-text);
    transition: background 0.3s, color 0.3s;
  }
</style>
</head>
<body class="dark">
<header>
  <h1 onclick="window.location.href='home.html'">GameHub</h1>
  <nav>
    <ul>
      <li onclick="window.location.href='home.html'">Home</li>
      <li onclick="window.location.href='brain.html'">Puzzle Games</li>
    </ul>
  </nav>
  <button class="theme-btn" id="themeBtn">Theme: Dark</button>
</header>

<div id="controls"></div>

<canvas id="gameCanvas" width="480" height="320"></canvas>
<div id="scoreboard"></div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let ballRadius = 8;
let x, y, dx, dy;

const paddleHeight = 10;
let paddleWidth = 75;
let paddleX;

let rightPressed = false;
let leftPressed = false;

let brickRowCount; 
let brickColumnCount; 
const brickWidth = 55;
const brickHeight = 20;
const brickPadding = 7;
const brickOffsetTop = 30;
const brickOffsetLeft = 30;
let bricks = [];

let score = 0;
let lives = 3;
let level = 1;
let maxLevel = 5;

document.addEventListener("keydown", keyDownHandler);
document.addEventListener("keyup", keyUpHandler);
document.addEventListener("mousemove", mouseMoveHandler);

const themeBtn = document.getElementById("themeBtn");

themeBtn.addEventListener("click", () => {
  if(document.body.classList.contains("dark")) {
    document.body.classList.remove("dark");
    document.body.classList.add("bright");
    themeBtn.textContent = "Theme: Bright";
  } else {
    document.body.classList.remove("bright");
    document.body.classList.add("dark");
    themeBtn.textContent = "Theme: Dark";
  }
});

function keyDownHandler(e) {
  if(e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
  else if(e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
}
function keyUpHandler(e) {
  if(e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
  else if(e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
}
function mouseMoveHandler(e) {
  let relativeX = e.clientX - canvas.getBoundingClientRect().left;
  if(relativeX > 0 && relativeX < canvas.width) {
    paddleX = relativeX - paddleWidth/2;
  }
}

function initBricks() {
  bricks = [];
  brickRowCount = 4 + Math.min(level, 3);
  brickColumnCount = 5 + Math.min(level, 4);
  for(let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for(let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {x:0, y:0, status: 1};
    }
  }
}

function resetBallAndPaddle() {
  x = canvas.width / 2;
  y = canvas.height - 30;
  dx = 2 + level * 0.5;
  dy = -(2 + level * 0.5);
  paddleX = (canvas.width - paddleWidth) / 2;
}

function collisionDetection() {
  for(let c = 0; c < brickColumnCount; c++) {
    for(let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r];
      if(b.status === 1) {
        if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
          dy = -dy;
          b.status = 0;
          score++;
          if(score === brickRowCount * brickColumnCount * level) {
            if(level < maxLevel) {
              level++;
              initBricks();
              resetBallAndPaddle();
            } else {
              alert("ðŸ† You completed all levels! Congratulations!");
              document.location.reload();
            }
          }
        }
      }
    }
  }
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI*2);
  ctx.fillStyle = "#ff0";
  ctx.fill();
  ctx.closePath();
}
function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = "#0f0";
  ctx.fill();
  ctx.closePath();
}
function drawBricks() {
  for(let c = 0; c < brickColumnCount; c++) {
    for(let r = 0; r < brickRowCount; r++) {
      if(bricks[c][r].status === 1) {
        let brickX = (c*(brickWidth+brickPadding)) + brickOffsetLeft;
        let brickY = (r*(brickHeight+brickPadding)) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = `hsl(${(c*30 + r*20) % 360}, 70%, 50%)`;
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}
function drawScore() {
  document.getElementById("scoreboard").textContent = 
    `Score: ${score} Â  Lives: ${lives} Â  Level: ${level}`;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawScore();
  collisionDetection();

  if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
  if(y + dy < ballRadius) dy = -dy;
  else if(y + dy > canvas.height - ballRadius) {
    if(x > paddleX && x < paddleX + paddleWidth) {
      let hitPos = x - (paddleX + paddleWidth/2);
      dx = hitPos * 0.15 + dx;
      dy = -dy;
    }
    else {
      lives--;
      if(!lives) {
        alert("GAME OVER");
        document.location.reload();
      } else {
        resetBallAndPaddle();
      }
    }
  }

  if(rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 5;
  else if(leftPressed && paddleX > 0) paddleX -= 5;

  x += dx;
  y += dy;
  requestAnimationFrame(draw);
}

initBricks();
resetBallAndPaddle();
draw();
</script>
</body>
</html>
